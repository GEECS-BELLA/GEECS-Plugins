import png
from nptdms import TdmsFile
import logging
from pathlib import Path
import re
import xml.etree.ElementTree as ET
from datetime import datetime
from zoneinfo import ZoneInfo  # Available in Python 3.9+

try:  # TODO this makes this module awkward.  Could perhaps this be moved outside of scan_analysis?
    import scan_analysis.third_party_sdks.wavekit_43.wavekit_py as wkpy
except:
    logging.warning(f'wavekit not installed properly')


def extract_timestamp_from_file(device_file: Path, device_type: str) -> float:
    """
    Extract timestamp from a device file based on its type.

    Args:
        device_file (Path): Path to the device file.
        device_type (str): Type of the device.

    Returns:
        float: Extracted timestamp.  (in epoch seconds)
    """
    device_exceptions = {}  # See `extract_timestamp_from_metadata()` for device types to use if filename does not work

    if device_type in device_exceptions:
        return extract_timestamp_from_metadata(device_file, device_type)
    else:
        return timestamp_from_filename(device_file)


def timestamp_from_filename(file: Path) -> float:
    """
    Extract timestamp from the file's filename, as of 04/14/2025 this has been changed to be saved in epoch seconds.

    :param file: Path object for given file
    :return: Extracted timestamp.  (in epoch seconds)
    """
    return timestamp_from_string(file.name)


def timestamp_from_string(string: str) -> float:
    """
    Extract timestamp from a given string.  Attempts to match it to a regular expression for epoch seconds (3 decimals)

    :param string: Input string
    :return: Extracted timestamp
    """
    pattern = r'_(\d+\.\d{3})\.[^.]+$'
    match = re.search(pattern, string)
    if match:
        return float(match.group(1))
    else:
        raise ValueError(f"Could not extract timestamp from '{string}'")


def extract_timestamp_from_metadata(device_file: Path, device_type: str) -> float:
    """
        Extract timestamp from a device file based on its type.
        Args:
            device_file (Path): Path to the device file.
            device_type (str): Type of the device.
        Returns:
            float: Extracted timestamp.
    """
    device_map = {
        "Point Grey Camera": get_imaq_timestamp_from_png,
        "MagSpecCamera": get_imaq_timestamp_from_png,
        "PicoscopeV2": get_picoscopeV2_timestamp,
        "MagSpecStitcher": get_custom_imaq_timestamp,
        "FROG": get_custom_imaq_timestamp,
        "HASO4_3": get_himg_timestamp,
        "Thorlabs CCS175 Spectrometer": get_picoscopeV2_timestamp,
        "RohdeSchwarz_RTA4000": get_picoscopeV2_timestamp,
    }
    if device_type in device_map:
        return device_map[device_type](device_file)
    else:
        raise ValueError(f"Unsupported device type: {device_type}")


def make_text_chunk_dict(text_chunks):
    """
    converts a list of tEXt chunks extracted from png header into a dict
    using the assumption that the keyword is separated from its value by
    a b'\x00' character. Raw byte information is un altered
    """
    text_chunk_dict = {}
    for chunk_data in text_chunks:
        null_pos = chunk_data.find(b'\x00')
        if null_pos != -1:
            chunk_keyword = chunk_data[:null_pos].decode('utf-8')
            chunk_content = chunk_data[null_pos + 1:]
            text_chunk_dict[chunk_keyword] = chunk_content
    return text_chunk_dict


def get_text_chunks(fname):
    """
    reads through header chunks of a png image, extracts the tEXt chunks
    and converts it to a dict with keyword:raw bytes info
    """
    chunkread = png.Reader(filename=fname)

    text_chunks = []
    stop_reading = False
    while not stop_reading:

        chunk_type, chunk_val = chunkread.chunk()

        if chunk_type == b'IDAT':
            stop_reading = True
            break
        elif chunk_type == b'tEXt':
            text_chunks.append(chunk_val)

    return make_text_chunk_dict(text_chunks)


def get_imaq_timestamp_from_png(fname):
    """
    returns the timestamp of a png file saved with IMAQdx in seconds format
    """
    text_chunks = get_text_chunks(fname)

    # Convert bytes to integer values
    high_value = int.from_bytes(text_chunks['IMAQdxTimestampHigh'], 'big')
    low_value = int.from_bytes(text_chunks['IMAQdxTimestampLow'], 'big')

    # Combine high and low to get the full timestamp in nanoseconds
    timestamp = (high_value << 32) + low_value

    # Convert nanoseconds to seconds
    timestamp_seconds = timestamp * 8e-9
    return timestamp_seconds


def get_custom_imaq_timestamp(fname):
    """
    returns the timestamp of png generated by a magspecstitcher and FROG devicetype
    note: these two device types have a custom timestamp written to the files in the same way
    new camera types that don't have a native timestamp from the hardware should use this
    """
    text_chunks = get_text_chunks(fname)

    # Convert bytes to integer values
    high_value = text_chunks['IMAQdxTimestampHigh']
    low_value = text_chunks['IMAQdxTimestampLow']

    timestamp_seconds = (int(high_value, 2) * 2 ** 32 + int(low_value, 2)) / 1e9

    return timestamp_seconds


def get_picoscopeV2_timestamp(file_path):
    """
    Retrieve the 'timestamp' property from a TDMS file efficiently.

    Args:
        file_path (str or Path): Path to the TDMS file.

    Returns:
        The timestamp if it exists, or None otherwise.
    """
    try:
        # Open the TDMS file and retrieve properties
        with TdmsFile.open(file_path) as tdms_file:
            return tdms_file.properties.get('timestamp')
    except FileNotFoundError:
        print(f"File not found: {file_path}")
        return None
    except OSError as e:
        # Catch other I/O-related errors (e.g., permissions, corrupt file)
        print(f"Error accessing file '{file_path}': {e}")
        return None


def get_haso_timestamp(file_path):
    """
    Extracts the 'acquisition_date' from the XML file at file_path and converts it
    to LabVIEW absolute time in seconds (seconds since Jan 1, 1904 in Pacific Time).

    Parameters:
        file_path (str): Path to the XML file.

    Returns:
        int: LabVIEW absolute time in seconds.
    """
    # Parse the XML file
    tree = ET.parse(file_path)
    root = tree.getroot()

    # Find the <acquisition_date> element; adjust the path if needed.
    date_elem = root.find(".//acquisition_date")
    if date_elem is None or date_elem.text is None:
        raise ValueError("The XML file does not contain a valid <acquisition_date> element.")

    # Extract the timestamp string (assumed to be in ISO8601 format)
    acquisition_date_str = date_elem.text.strip()

    # Parse the timestamp string. fromisoformat supports ISO8601.
    dt = datetime.fromisoformat(acquisition_date_str)

    # If the datetime is naive (no timezone), assume it is Pacific Time.
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=ZoneInfo("America/Los_Angeles"))

    # Define LabVIEW's epoch (January 1, 1904) in Pacific Time.
    lv_epoch = datetime(1904, 1, 1, 0, 0, 0, tzinfo=ZoneInfo("America/Los_Angeles"))

    # Compute the time difference in seconds.
    delta = dt - lv_epoch
    time_zone_offset = 3600 * 8
    labview_seconds = delta.total_seconds() + time_zone_offset

    return labview_seconds


def get_himg_timestamp(image_file_path: Path) -> float:
    image_file_path_str = str(image_file_path)

    # haso_image = wkpy.Image(image_file_path =image_file_path_str)
    # meta_data = haso_image.get_info_from_file(image_file_path_str)[1]
    meta_data = wkpy.Image.get_info_from_file(image_file_path_str)[1]

    timestamp = meta_data[2]
    return timestamp
