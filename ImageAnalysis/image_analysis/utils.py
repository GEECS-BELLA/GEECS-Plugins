from __future__ import annotations

from pathlib import Path
from typing import Union, Optional
from warnings import warn

import numpy as np
import png
from imageio.v3 import imread, imopen

###new dependencies added by Sam
import struct
import re
from nptdms import TdmsFile
import logging

import xml.etree.ElementTree as ET
from datetime import datetime
from zoneinfo import ZoneInfo  # Available in Python 3.9+

try:
    import scan_analysis.third_party_sdks.wavekit_43.wavekit_py as wkpy
except:
    logging.warning(f'wavekit not installed properly')
    
def read_imaq_png_image(file_path: Union[Path, str]) -> np.ndarray:
    """ Read PNG file as output by NI IMAQ, which uses an uncommon format.
    """
    with file_path.open('rb') as f:
        png_reader = png.Reader(f)

        # read operations returns rows as a generator. it also adds png headers
        # as attributes to png_reader, including sbit
        width, height, rows, info = png_reader.read()
        significant_bits = png_reader.sbit

        # NI IMAQ images use 16 bits per pixel (uncompressed) but often only 
        # the left 12 bits for the data, which is given in the sbit header. 
        # PNG readers don't account for this, so we right shift manually.
        bitdepth = info['bitdepth']
        image = np.array(list(rows), f'uint{bitdepth:d}')

    if significant_bits is None:
        return image
    else:
        significant_bits = ord(significant_bits)
        return np.right_shift(image, bitdepth - significant_bits)

def read_imaq_image(file_path: Union[Path, str]) -> np.ndarray:
    """ Read BELLA camera image, in particular handle NI PNG files correctly.
    """
    file_path = Path(file_path)

    if file_path.suffix.lower() == '.png':
        return read_imaq_png_image(file_path)
    elif file_path.suffix.lower() == '.npy':
        return np.load(file_path)
    else:
        return imread(file_path)

def make_text_chunk_dict(text_chunks):
    """
    converts a list of tEXt chunks extracted from png header into a dict
    using the assumption that the keyword is separated from its value by
    a b'\x00' character. Raw byte information is un altered
    """
    text_chunk_dict = {}
    for chunk_data in text_chunks:
        null_pos = chunk_data.find(b'\x00')
        if null_pos != -1:
            chunk_keyword = chunk_data[:null_pos].decode('utf-8')
            chunk_content = chunk_data[null_pos+1:]
            text_chunk_dict[chunk_keyword] = chunk_content
    return text_chunk_dict

def get_text_chunks(fname):
    """
    reads through header chunks of a png image, extracts the tEXt chunks 
    and converts it to a dict with keyword:raw bytes info
    """
    chunkread = png.Reader(filename=fname)

    text_chunks = []
    stop_reading = False
    while not stop_reading:
        
        chunk_type, chunk_val = chunkread.chunk()

        if chunk_type == b'IDAT':
            stop_reading = True
            break
        elif chunk_type == b'tEXt':
            text_chunks.append(chunk_val)

    return make_text_chunk_dict(text_chunks)

def get_imaq_timestamp_from_png(fname):
    """
    returns the timestamp of a png file saved with IMAQdx in seconds format
    """
    text_chunks = get_text_chunks(fname)
    
    # Convert bytes to integer values
    high_value = int.from_bytes(text_chunks['IMAQdxTimestampHigh'],'big')
    low_value = int.from_bytes(text_chunks['IMAQdxTimestampLow'],'big')

    # Combine high and low to get the full timestamp in nanoseconds
    timestamp = (high_value << 32) + low_value

    # Convert nanoseconds to seconds
    timestamp_seconds = timestamp * 8e-9
    return timestamp_seconds
    
def get_custom_imaq_timestamp(fname):
    """
    returns the timestamp of png generated by a magspecstitcher and FROG devicetype
    note: these two device types have a custom timestamp written to the files in the same way
    new camera types that don't have a native timestamp from the hardware should use this
    """
    text_chunks = get_text_chunks(fname)
    
    # Convert bytes to integer values
    high_value = text_chunks['IMAQdxTimestampHigh']
    low_value = text_chunks['IMAQdxTimestampLow']

    timestamp_seconds = (int(high_value,2)*2**32 + int(low_value,2)) / 1e9
    
    return timestamp_seconds
        
def get_picoscopeV2_timestamp(file_path):
    """
    Retrieve the 'timestamp' property from a TDMS file efficiently.

    Args:
        file_path (str or Path): Path to the TDMS file.

    Returns:
        The timestamp if it exists, or None otherwise.
    """
    try:
        # Open the TDMS file and retrieve properties
        with TdmsFile.open(file_path) as tdms_file:
            return tdms_file.properties.get('timestamp')
    except FileNotFoundError:
        print(f"File not found: {file_path}")
        return None
    except OSError as e:
        # Catch other I/O-related errors (e.g., permissions, corrupt file)
        print(f"Error accessing file '{file_path}': {e}")
        return None
        
def get_haso_timestamp(file_path):
    """
    Extracts the 'acquisition_date' from the XML file at file_path and converts it
    to LabVIEW absolute time in seconds (seconds since Jan 1, 1904 in Pacific Time).

    Parameters:
        file_path (str): Path to the XML file.

    Returns:
        int: LabVIEW absolute time in seconds.
    """
    # Parse the XML file
    tree = ET.parse(file_path)
    root = tree.getroot()

    # Find the <acquisition_date> element; adjust the path if needed.
    date_elem = root.find(".//acquisition_date")
    if date_elem is None or date_elem.text is None:
        raise ValueError("The XML file does not contain a valid <acquisition_date> element.")

    # Extract the timestamp string (assumed to be in ISO8601 format)
    acquisition_date_str = date_elem.text.strip()

    # Parse the timestamp string. fromisoformat supports ISO8601.
    dt = datetime.fromisoformat(acquisition_date_str)

    # If the datetime is naive (no timezone), assume it is Pacific Time.
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=ZoneInfo("America/Los_Angeles"))

    # Define LabVIEW's epoch (January 1, 1904) in Pacific Time.
    lv_epoch = datetime(1904, 1, 1, 0, 0, 0, tzinfo=ZoneInfo("America/Los_Angeles"))

    # Compute the time difference in seconds.
    delta = dt - lv_epoch
    time_zone_offset = 3600*8
    labview_seconds = delta.total_seconds() + time_zone_offset

    return labview_seconds
    
def get_himg_timestamp(image_file_path: Path)-> float:
    image_file_path_str = str(image_file_path)

    # haso_image = wkpy.Image(image_file_path =image_file_path_str)
    # meta_data = haso_image.get_info_from_file(image_file_path_str)[1]
    meta_data = wkpy.Image.get_info_from_file(image_file_path_str)[1]

    timestamp = meta_data[2]
    return timestamp

def extract_timestamp_from_file(device_file: Path, device_type: str) -> float:
    """
    Extract timestamp from a device file based on its type.

    Args:
        device_file (Path): Path to the device file.
        device_type (str): Type of the device.

    Returns:
        float: Extracted timestamp.
    """
    device_map = {
        "Point Grey Camera": get_imaq_timestamp_from_png,
        "MagSpecCamera": get_imaq_timestamp_from_png,
        "PicoscopeV2": get_picoscopeV2_timestamp,
        "MagSpecStitcher": get_custom_imaq_timestamp,
        "FROG": get_custom_imaq_timestamp,
        "HASO4_3": get_himg_timestamp,
        "Thorlabs CCS175 Spectrometer": get_picoscopeV2_timestamp,
    }

    if device_type in device_map:
        return device_map[device_type](device_file)
    else:
        raise ValueError(f"Unsupported device type: {device_type}")

def extract_shot_number(filename):
    """
    Extract the shot number from the filename.

    Args:
        filename (str): The filename from which to extract the shot number.

    Returns:
        int: The extracted shot number, or None if the format is incorrect.
    """
    # Match the last number before the .png extension
    match = re.search(r'_(\d+)\.png$', filename)
    if match:
        return int(match.group(1))
    return None

class ROI:
    """ Specify a region of interest for an ImageAnalyzer to crop with.
    
    This is given a class so that there can be no confusion about the order
    of indices.

    Initialized with top, bottom, left, right indices. Cropping is done with
    slices containing these indices, which means: 
        * None is valid, meaning go to the edge
        * Negative integers are valid, which means up to edge - value.
        * The top and left indices are inclusive, and bottom and right indices
          are exclusive.

    The convention of (0, 0) at the top left corner is used, which means 
    top should be less than bottom. 

    If not given as kwargs, the coordinates are in order that they would be 
    used in slicing: 
        image[i0:i1, i2:i3]

    """
    def __init__(self, top: Optional[int] = None, 
                       bottom: Optional[int] = None, 
                       left: Optional[int] = None, 
                       right: Optional[int] = None,
                       bad_index_order = 'raise',
                ):

        """
        Parameters
        ----------
        top, bottom, left, right : Optional[int]
            indices of ROI. Cropping is done with slices containing these indices,
            which means: 
                * None is valid, meaning go to the edge
                * Negative integers are valid, which means up to edge - value.
                * The top and left indices are inclusive, and bottom and right indices
                  are exclusive.

            The convention of (0, 0) at the top left corner is used, which means 
            top should be less than bottom. 

        bad_index_order : one of 'raise', 'invert', 'invert_warn'
            what to do if top > bottom, or right > left
                'raise': raise ValueError
                'invert': silently switch top/bottom, or left/right indices
                'invert_warn': switch top/bottom or left/right indices with warning.

        """

        def check_index_order(low_name, low_index, high_name, high_index):
            """ Checks whether low_index < high_index, and takes appropriate action.

            Returns
            -------
            low_index, high_index : int
                possibly inverted.

            """
            if low_index is None or high_index is None:
                return low_index, high_index

            if low_index > high_index:
                if bad_index_order == 'raise': 
                    raise ValueError(f"{low_index} should be less than {high_index} ((0, 0) is at the top left corner)")
                elif bad_index_order == 'invert':
                    low_index, high_index = high_index, low_index
                elif bad_index_order == 'invert_warn':
                    low_index, high_index = high_index, low_index
                    warn(f"Inverting {low_index} and {high_index}.")
                else:
                    raise ValueError(f"Unknown action for bad_index_order: {bad_index_order}")

            return low_index, high_index

        top, bottom = check_index_order('top', top, 'bottom', bottom)
        left, right = check_index_order('left', left, 'right', right)

        self.top = top
        self.bottom = bottom
        self.left = left
        self.right = right

    def crop(self, image: np.ndarray):
        return image[self.top:self.bottom, self.left:self.right]

    def __str__(self):
        return repr(self)

    def __repr__(self):
        return f"ROI({self.top}, {self.bottom}, {self.left}, {self.right})"
    
class NotAPath(Path().__class__):
    """ A Path instance that evaluates to false in, for example, if statements.
    """
    def __bool__(self):
        return False

    def is_file(self):
        return False

    def is_dir(self):
        return False

    def exists(self):
        return False
