"""Interface to WFS driver based on sample applications (Windows-only)

This code includes several major classes, of which two are used only by the
WfsInstrument class for data storage (WfsImage, WfsInfo)

WfsInfo  : data required for managing instrument settings and parameters
WfsImage : data buffers and image information

The other classes in this file are used to provide a direct interface to the
Thorlabs NI CVI camera driver and to wrap the functions themselves with Python
methods

WfsInterface : interface to driver
Wfs20Instrument : Instrument management and interaction methods
"""
import os
import ctypes
import numpy as np
import re

import logging

logging.basicConfig()
LOG = logging.getLogger("wfs")

class WfsInterface(ctypes.WinDLL):
    """Class for interacting with driver and cataloging defines and methods based on header files

    Includes methods necessary to load the camera driver, parse the driver header files to set the
    correct argument types for each function in the DLL, and methods associated with supporting
    this process"""

    VI_SUCCESS = 0
    VI_NULL = 0
    VI_TRUE = 1
    VI_FALSE = 0

    # https://stackoverflow.com/questions/25735506/python-regex-reading-in-c-style-comments#25735600
    COMMENT_RE = re.compile(
        r"""(?x)
        (?=["'/])      # trick to make it faster, a kind of anchor
        (?:
            "(?=((?:[^"\\?]+|\?(?!\?/)|(?:\?\?/|\\)[\s\S])*))\1" # double quotes string
        |
            '(?=((?:[^'\\?]+|\?(?!\?/)|(?:\?\?/|\\)[\s\S])*))\2' # single quotes string
        |
            (
                /(?:(?:\?\?/|\\)\n)*/(?:.*(?:\?\?|\\)/\n)*.* # single line comment
            |
                /(?:(?:\?\?/|\\)\n)*\*                       # multiline comment
                (?=((?:[^*]+|\*+(?!(?:(?:\?\?/|\\)\n)*/))*))\4
                \*(?:(?:\?\?/|\\)\n)*/
            )
        )
        """
    )

    def __init__(self, *args, arch="x86_64", **kwargs):
        """Load driver and header files for use in this class"""
        if arch == "x86_64":
            self.DLL_DIRECTORY = "C:\\Program Files\\IVI Foundation\\VISA\\Win64\\Bin\\"
            self.DLL_NAME = "WFS_64.dll"
        elif arch == "x86":
            self.DLL_DIRECTORY = "C:/Program Files (x86)/IVI Foundation/VISA/WinNT/Bin/"
            self.DLL_NAME = "WFS_32.dll"
        os.add_dll_directory(self.DLL_DIRECTORY)
        super().__init__(self.DLL_NAME)

        # Load and parse include files for proper DLL interfacing
        self.INCLUDE_PATH = os.path.join(self.DLL_DIRECTORY, "../include")
        self.WFS_HEADER_FILE = os.path.join(self.INCLUDE_PATH, "WFS.h")
        self.VISA_HEADER_FILE = os.path.join(self.INCLUDE_PATH, "visatype.h")
        self.loadMethods()
        self._associate_visa_types()

    @staticmethod
    def _str_to_char_p(val):
        """Convert a ctype to a ctypes.c_char_p

        Args:
            val (ctype): initial ctypes object

        Returns:
            ctypes.POINTER(ctypes.c_char_p) : character pointer
        """
        return ctypes.cast(val, ctypes.POINTER(ctypes.c_char))

    @staticmethod
    def sanitizeDefinesDict(definesDict):
        """Sanitize dictionary generated by header file parsing of defines

        Args:
            definesDict (dict): dictionary of {define:value}
        """
        for name, value in definesDict.items():
            # If value isn't an int or float, try to convert it
            if not isinstance(value, (int, float)):
                try:
                    value = float(value)
                    if int(value) == value:
                        value = int(value)
                except ValueError as ie:
                    if value[:2] == "0x" and value[-1] == "L":
                        value = int(value[:-1], base=16)
                    else:
                        LOG.debug("%s for %s", ie, name)

            definesDict[name] = value

    @staticmethod
    def sanitizeFunctionsDict(funcDict):
        """Sanitize dictionary generated by header file parsing of functions

        Args:
            funcDict (dict): dictionary of {func_name:args}
        """
        for name, args in funcDict.items():
            try:
                # Clean up arguments
                # Remove end-of-line terminators
                args = args.replace("\n", "")
                # Split arguments
                args = args.split(",")
                # Remove leading whitespace
                args = [x.lstrip() for x in args]
            except AttributeError as e:
                LOG.error(e)
            funcDict[name] = tuple(args)

    def _loadWfsHeader(self, fname):
        """Load WFS.h header file

        Loads defines and functions in to dicts that live within the class

        Args:
            fname (str) : file path to WFS.h header"""

        # #define re string
        # `` #define  NOT_CENTERED                  (0)  // ``
        defRe = re.compile(
            r"^#define\s+(?P<name>\w+)\s+\([ \t]*(?P<value>[ +*\w\.]+)[ \t]*\)\s+",
            flags=re.MULTILINE,
        )

        # function and argument string
        fnRe = re.compile(
            r"^ViStatus _VI_FUNC (?P<name>\w*) \((?P<args>Vi[^;]+)\);\n",
            flags=re.MULTILINE,
        )

        # Read in header file
        with open(fname, "r") as rf:
            raw = rf.read()

        # Remove block comments
        raw = self.COMMENT_RE.sub("", raw, count=1000)

        # Find all defines and build define: value dict
        for match in defRe.finditer(raw):
            self.defines[match.group("name")] = match.group("value")
        self.sanitizeDefinesDict(self.defines)

        # # Find all functions and build function: args dict
        for match in fnRe.finditer(raw):
            self.functions[match.group("name")] = match.group("args")
        self.sanitizeFunctionsDict(self.functions)

        LOG.info("Found %d defines", len(self.defines))
        LOG.info("Found %d functions", len(self.functions))

    def loadMethods(self):
        """Create local data objects and call method to load WFS header"""
        self.defines = {}
        self.functions = {}
        self._loadWfsHeader(self.WFS_HEADER_FILE)

        # TODO Parse visatype.h to get defines
        # self._loadVisaTypes(self.VISA_HEADER_FILE)

        # self._associate_visa_types()

        # self._build_ctypes_functions()

    def getUniqueArgs(self):
        """Unused method to name function arguments uniquely

        Raises:
            NotImplementedError : unused method"""
        raise NotImplementedError()
        # alist = set()
        # for args in self.functions.values():
        #     for arg in args:
        #         testList = arg.split(" ")
        #         # if not alpha numeric, probably an array. Test
        #         pre = ""
        #         post = ""
        #         if not testList[-1].isalnum():
        #             LOG.debug(testList[-1])
        #             if testList[-1][-2:] == "[]":
        #                 # is array
        #                 post = "_arr"
        #             elif testList[-1][0] == "*":
        #                 pre = "PTR_"
        #             elif testList[-1][-1] == "]":
        #                 post = "_2darr"
        #         if testList[0] == "":
        #             LOG.debug(arg)
        #         # Add base type
        #         alist.add(pre + testList[0] + post)
        # LOG.debug(alist)


    def _loadVisaTypes(self, fname):
        """Reads in relevant parts of visatypes.h and build type table

        Args:
            fname (str): path to visatype.h header file

        Raises:
            NotImplementedError: [description]
        """
        raise NotImplementedError

    def _associate_visa_types(self):
        """Associates VISA types with fundamental types

        Modifies WFS.h function arguments to have fundamental ctypes instead
        of VISA-type strings. Modifies WinDLL function parameters to have
        proper argument types
        """
        self.func_argtypes = {}
        for fn, args in self.functions.items():
            argtypes = []
            for arg in args:
                testList = arg.split(" ")

                # Identify variable type
                typeVar = testList[0]
                if "UInt32" in typeVar:
                    baseType = ctypes.c_uint32
                elif "UInt16" in typeVar:
                    baseType = ctypes.c_uint16
                elif "UInt8" in typeVar:
                    baseType = ctypes.c_uint8
                if "Int32" in typeVar:
                    baseType = ctypes.c_int32
                elif "Int16" in typeVar:
                    baseType = ctypes.c_int16
                elif "Int8" in typeVar:
                    baseType = ctypes.c_int8
                elif "Real64" in typeVar:
                    baseType = ctypes.c_double
                elif "Session" in typeVar:
                    baseType = ctypes.c_uint
                elif "Boolean" in typeVar:
                    baseType = ctypes.c_bool
                elif "Char" in typeVar:
                    baseType = ctypes.c_char
                elif "float" in typeVar:
                    baseType = ctypes.c_float
                elif "Status" in typeVar:
                    baseType = ctypes.c_int32
                elif "Rsrc" in typeVar:
                    baseType = ctypes.POINTER(ctypes.c_char)
                else:
                    raise ValueError("Unhandled Type %s" % typeVar)

                # Handle normal pointers and arrays
                if testList[1][0] == "*" or testList[-1][-2:] == "[]":
                    baseType = ctypes.POINTER(baseType)

                # Handle 2D arrays -- the same for now, need dimensionality encoded somewhere
                elif testList[-1][-1:] == "]":
                    # TODO Currently unused, but can constrain dimension
                    terms = re.split(r"[\[\]]", testList[-1])
                    dim0 = self.defines[terms[-4]]
                    dim1 = self.defines[terms[-2]]

                    # Handle 2D arrays
                    baseType = ctypes.POINTER(baseType)

                if testList[0].startswith("ViA"):
                    baseType = ctypes.POINTER(baseType)

                argtypes.append(baseType)
            # Save argtypes
            self.func_argtypes[fn] = argtypes
            # Setup function in driver
            # restype is usually ViStatus, so the default c_long is fine
            getattr(self, fn).argtypes = argtypes
            LOG.debug("%s : %s", fn, getattr(self, fn).argtypes)

    def _build_ctypes_functions(self):
        """Takes in association table and data and builds proper ctypes function calls

        Sets restype and argtypes properly for code that uses this interface to easily
        communicate with the driver

        Raises:
            NotImplementedError: [description]
        """
        raise NotImplementedError


class WfsInfo:
    """Data class for information used in managing instrument"""

    def __init__(self, buffer_size=256, spots=(256, 256)):
        self.status = ctypes.c_int()
        self.device_id = ctypes.c_uint()
        self.version_wfs_driver = ctypes.create_string_buffer(buffer_size)
        self.version_cam_driver = ctypes.create_string_buffer(buffer_size)
        self.manufacturer_name = ctypes.create_string_buffer(buffer_size)
        self.instrument_name = ctypes.create_string_buffer(buffer_size)
        self.serial_number_wfs = ctypes.create_string_buffer(buffer_size)
        self.serial_number_cam = ctypes.create_string_buffer(buffer_size)

        self.mla_cnt = 0
        self.selected_mla = 0
        self.selected_mla_idx = ctypes.c_int()
        self.mla_name = ctypes.create_string_buffer(buffer_size)
        self.cam_pitch_um = ctypes.c_double()
        self.lenslet_pitch_um = ctypes.c_double()
        self.center_spot_offset_x = ctypes.c_double()
        self.center_spot_offset_y = ctypes.c_double()
        self.lenslet_f_um = ctypes.c_double()
        self.grd_corr_0 = ctypes.c_double()
        self.grd_corr_45 = ctypes.c_double()
        self.spots_x = ctypes.c_int()
        self.spots_y = ctypes.c_int()

        # highspeed windows data
        self.hs_win_count_x = ctypes.c_int()
        self.hs_win_count_y = ctypes.c_int()
        self.hs_win_size_x = ctypes.c_int()
        self.hs_win_size_y = ctypes.c_int()
        self.hs_win_start_x = np.zeros(spots[0], dtype=np.int32)
        self.hs_win_start_y = np.zeros(spots[1], dtype=np.int32)

        # Pupil information
        self.centroid_x = ctypes.c_double(0.0)
        self.centroid_y = ctypes.c_double(0.0)
        self.diameter_x = ctypes.c_double(2.0)
        self.diameter_y = ctypes.c_double(2.0)


class WfsImage:
    """Data class to support image-related data"""

    def __init__(self, maxLine=1440, spots=(180,180), maxZernikeModes=66):
        self.ImageBufferRef = ctypes.POINTER(ctypes.c_int8)()
        self.SpotfieldImage = None
        self.rows = ctypes.c_int()
        self.cols = ctypes.c_int()
        self.expos_act = ctypes.c_double()
        self.master_gain_act = ctypes.c_double()

        self.intensities = np.zeros(spots, dtype=np.float)
        self.spotdims = spots

        self.line = np.zeros(maxLine, dtype=np.float)
        self.lineMin = np.zeros(maxLine, dtype=np.float)
        self.lineMax = np.zeros(maxLine, dtype=np.float)

        self.arrayDeviationsX = np.zeros(spots, dtype=np.float)
        self.arrayDeviationsY = np.zeros(spots, dtype=np.float)

        self.arrayCentroidsX = np.zeros(spots, dtype=np.float)
        self.arrayCentroidsY = np.zeros(spots, dtype=np.float)

        # Zernike calculations
        self.zernikeOrders = None
        self.arrayZernikeUm = np.zeros(maxZernikeModes+1, dtype=np.float)
        self.arrayZernikeOrdersUm = np.zeros(maxZernikeModes+1, dtype=np.float)
        self.roCMm = ctypes.c_double()

class Wfs20Instrument:
    """Instrument management class

    Management methods and interface to get data and configure instrument"""

    # Device offset used to determine device type
    DEVOFFSET = 512
    MAXLINE = 1440

    STATUS = {
        "WFS_STATBIT_CON" : (0x00000001, "USB CONnection to device lost"),
        "WFS_STATBIT_PTH" : (0x00000002, "Power Too High (cam saturated)"),
        "WFS_STATBIT_PTL" : (0x00000004, "Power Too Low (low cam digits)"),
        "WFS_STATBIT_HAL" : (0x00000008, "High Ambient Light"),
        "WFS_STATBIT_SCL" : (0x00000010, "Spot Contrast too Low"),
        "WFS_STATBIT_ZFL" : (0x00000020, "Zernike fit Failed, Low spots no."),
        "WFS_STATBIT_ZFH" : (0x00000040, "Zernike fit Failed, High spots no."),
        "WFS_STATBIT_ATR" : (0x00000080, "Camera is still Awaiting a TRigger"),
        "WFS_STATBIT_CFG" : (0x00000100, "Camera is ConFiGured"),
        "WFS_STATBIT_PUD" : (0x00000200, "PUpil is Defined"),
        "WFS_STATBIT_SPC" : (0x00000400, "No. of Spots or Pupil Changed"),
        "WFS_STATBIT_RDA" : (0x00000800, "Reconstr. spot Deviation Available"),
        "WFS_STATBIT_URF" : (0x00001000, "No User ReFerence available"),
        "WFS_STATBIT_HSP" : (0x00002000, "Camera is in HighSPeed Mode"),
        "WFS_STATBIT_MIS" : (0x00004000, "MISmatched centroids in Highspeed Mode"),
        "WFS_STATBIT_LOS" : (0x00008000, "LOw Spot count within pupil, reduces Zernike accuracy"),
        "WFS_STATBIT_FIL" : (0x00010000, "Pupil badly FILled with spots"),
    }

    # //     Device IDs of WFS10 instruments start at 256 decimal
    # public static int DeviceOffsetWFS10 = 256;
    # //     Device IDs of WFS20 instruments start at 512 decimal
    # public static int DeviceOffsetWFS20 = 512;
    # //     Device IDs of WFS30 instruments start at 512 decimal
    # public static int DeviceOffsetWFS30 = 1024;
    # //     Device IDs of WFS30 instruments start at 512 decimal
    # public static int DeviceOffsetWFS40 = 2048;

    def __init__(self, dll, *args, instrIdx=0, mlaIdx=0, doInit=True, ignoreErrors=False, **kwargs):
        """Initializes Wfs20Instrument

        Args:
            dll (WfsInterface): interface to driver
            instrIdx (int, optional): index of which instrument to use. Defaults to 0.
            mlaIdx (int, optional): index of which MLA array to use. Defaults to 0.
            doInit (bool, optional): perform initialization of camera. Defaults to True.
            ignoreErrors (bool, optional): disables printing from handleError method. Defaults to False.

        Raises:
            RuntimeError: [description]
            RuntimeError: [description]
        """
        self.dll = dll
        # Spot dimensions
        spotdims = (
            self.dll.defines["MAX_SPOTS_X"],
            self.dll.defines["MAX_SPOTS_Y"],
        )

        # Build general information data class
        self.info = WfsInfo(
            self.dll.defines["WFS_BUFFER_SIZE"],
            spots=spotdims,
        )

        # Build general image data class. 1440 from WFS20 maximum resolution
        self.img = WfsImage(maxLine=self.MAXLINE, spots=spotdims, maxZernikeModes=self.dll.defines["MAX_ZERNIKE_MODES"])

        # Internal variables
        self.handle = None
        self.ignoreErrors = ignoreErrors
        self.status = 0
        self.hs_mode = False

        # Basic Instrument information
        self.numInst = self.getInstrumentCount()
        if self.numInst <= 0:
            raise RuntimeError("No WFS camera available")

        self.instrInfos = []
        for instrIdx in range(self.numInst):
            self.instrInfos.append(self.getInstrumentListInfo(instrIdx))
        LOG.info("Using instrument %d: %s", instrIdx, self.instrInfos[instrIdx])
        self._active_resource = self.instrInfos[instrIdx]["resource_name"]
        if not (self.instrInfos[instrIdx]["id"] & self.DEVOFFSET):
            raise RuntimeError("WFS20 device not selected")
        if doInit:
            # Initialize instrument
            self.initInstrument()
            LOG.info("Initialized with handle %d", self.handle.value)

            # Get instrument information
            self.getInstrumentInfo()
            LOG.info("Manufacturer %s", self.info.manufacturer_name.value)
            LOG.info("Instrument Name: %s", self.info.instrument_name.value)
            LOG.info("Serial Number WFS: %s", self.info.serial_number_wfs.value)

            # Get MLA information and select one
            self.getMlaCount()
            self.info.selected_mla = mlaIdx
            LOG.info(
                "Found %d MLA; using MLA %d for any calculations",
                self.info.mla_cnt,
                self.info.selected_mla,
            )
            self.getMLAData(self.info.selected_mla)

    def configureCamera(self):
        """Configures camera with fastest resolution that allows for high-speed mode

        This function configures the WFS instrument's camera resolution and returns the max. number of detectable spots in X and Y direction.
        The result depends on the selected microlens array in function WFS_SelectMla().
        Note: This function is not available in Highspeed Mode!
        """
        err = self.dll.WFS_ConfigureCam(
            self.handle,
            self.dll.defines["PIXEL_FORMAT_MONO8"],
            # Fastest "normal" mode that can change to HS mode
            self.dll.defines["CAM_RES_WFS20_360"],
            ctypes.byref(self.info.spots_x),
            ctypes.byref(self.info.spots_y),
        )
        self.handleError(err)

    def initInstrument(self, *args, **kwargs):
        """Initialize instrument, driver, and open connection

        This function initializes the instrument driver session and performs the following initialization actions:
        (1) Opens a session to the Default Resource Manager resource and a session to the selected device using the Resource Name.
        (2) Performs an identification query on the Instrument.
        (3) Resets the instrument to a known state.
        (4) Sends initialization commands to the instrument.
        (5) Returns an instrument handle which is used to differentiate between different sessions of this instrument driver.
        Notes:
        (1) Each time this function is invoked an unique session is opened."""
        handle = ctypes.c_uint()
        err = self.dll.WFS_init(self.dll._str_to_char_p(self._active_resource), 0, 0, ctypes.byref(handle))
        self.handle = handle
        self.handleError(err, "init")

        # Force reset and then self-test
        self.reset()
        self.selfTest()

    def close(self):
        """Closes instrument session

        This function closes the instrument driver session.
        Note: The instrument must be reinitialized to use it again. """
        err = self.dll.WFS_close(self.handle)
        self.handleError(err)

    def reset(self):
        """Places the instrument in a default state (if supported)"""
        self._check_handle()
        err = self.dll.WFS_reset(self.handle)
        if err == self.dll.defines["WFS_WARN_NSUP_RESET"]:
            LOG.warning("Reset not supported for this camera")
        elif err != self.dll.VI_SUCCESS:
            self.handleError(err, forcePrint=True)
            raise RuntimeError(self.handleError(err, forcePrint=True))

    def selfTest(self):
        """Runs an instrument self-test (if supported)"""
        self._check_handle()
        testResult = ctypes.c_int16()
        testMsg = ctypes.create_string_buffer(self.dll.defines["WFS_BUFFER_SIZE"])
        err = self.dll.WFS_self_test(self.handle, ctypes.byref(testResult), testMsg)
        if err == self.dll.defines["WFS_WARN_NSUP_SELF_TEST"]:
            LOG.warning("Self-test not supported for this camera")
            return
        elif testResult.value != 0:
            raise RuntimeError(testResult, testMsg.value)
        LOG.info("Self-test passed: %s", testMsg.value)
        self.handleError(err)

    def getStatus(self):
        """Gets status bits from instrument"""
        self._check_handle()
        status = ctypes.c_int()
        err = self.dll.WFS_GetStatus(self.handle, ctypes.byref(status))
        self.handleError(err)
        return status.value

    def printStatus(self, onlyPrintChanged=True):
        """Gets status bits and prints string representing status

        Args:
            onlyPrintChanged (bool) : Only print status strings for statuses that have changed. Defaults to True."""
        oldstatus = self.status
        self.status = self.getStatus()
        # statdict = {k:v for k,v in self.dll.defines.items() if k.beginswith("WFS_STATBIT")}
        if onlyPrintChanged:
            newstatus = self.status ^ oldstatus
        else:
            newstatus = self.status
        for k, v in self.STATUS.items():
            if newstatus & v[0]:
                LOG.warn("%s : %s", k, v[1])

    def _check_handle(self):
        """Checks if instrument handle has been initialized

        Raises:
            RuntimeError: Instrument must be initialized first
        """
        if self.handle is None:
            raise RuntimeError("Instrument must be initialized first")

    def getInstrumentCount(self):
        """Get number of instruments connected to machine"""
        count = ctypes.c_int()
        err = self.dll.WFS_GetInstrumentListLen(self.dll.VI_NULL, ctypes.byref(count))
        self.handleError(err, "get_count")
        return count.value

    def getInstrumentListInfo(self, idx=0):
        """List instrument information from driver

        Args:
            idx (int, optional): Local index of instrument. Defaults to 0.

        Returns:
            dict : instrument id, name, resource, and whether device is in use
        """

        # Get instrument information
        device_id = ctypes.c_int()
        in_use = ctypes.c_int()
        instr_name = ctypes.create_string_buffer(self.dll.defines["WFS_BUFFER_SIZE"])
        serNr = ctypes.create_string_buffer(self.dll.defines["WFS_BUFFER_SIZE"])
        resource_name = ctypes.create_string_buffer(self.dll.defines["WFS_BUFFER_SIZE"])
        err = self.dll.WFS_GetInstrumentListInfo(
            self.dll.VI_NULL,
            idx,
            ctypes.byref(device_id),
            ctypes.byref(in_use),
            instr_name,
            serNr,
            resource_name,
        )
        self.handleError(err, "list_info")
        return {
            "id": device_id.value,
            "in_use": in_use.value,
            "instrument_name": instr_name.value,
            "serial_number": serNr.value,
            "resource_name": resource_name.value,
        }

    def getDriverRevision(self):
        """Gets revision of driver and stores in self.info data class"""
        err = self.dll.WFS_revision_query(
            self.dll.VI_NULL,
            ctypes.byref(self.info.version_wfs_driver),
            ctypes.byref(self.info.version_cam_driver),
        )
        self.handleError(err)

    def getInstrumentInfo(self):
        """Get instrument information from driver

        Returns:
            Fills WfsInstrument.info object
        """
        # Get instrument information
        err = self.dll.WFS_GetInstrumentInfo(
            self.handle,
            self.info.manufacturer_name,
            self.info.instrument_name,
            self.info.serial_number_wfs,
            self.info.serial_number_cam,
        )
        self.handleError(err)

    def handleError(self, err, context="default", forcePrint=False):
        """[summary]

        Args:
            err (int): error code
            context (str, optional): log context for more informational logging. Defaults to "default".
            forcePrint (bool, optional): Print even if there is no error. Defaults to False.

        Returns:
            str or None: Returns error string or None
        """
        if self.ignoreErrors and not forcePrint:
            return
        if err:
            buf = ctypes.create_string_buffer(500)
            handle = self.dll.VI_NULL if self.handle is None else self.handle
            self.dll.WFS_error_message(handle, err, buf)
            LOG.error("%s: %s", context, buf.value)
            return f"{err}: {buf.value}"
        return None

    def getMlaCount(self):
        """Gets number of MLAs in instrument"""
        self._check_handle()
        mla_cnt = ctypes.c_int()
        self.err = self.dll.WFS_GetMlaCount(self.handle, ctypes.byref(mla_cnt))
        self.info.mla_cnt = mla_cnt.value

    def getMLAData(self, idx=0):
        """Retrieve information about an MLA on the instrument.

        Args:
            idx (int) : Index of MLA to get information on. Defaults to 0."""
        self._check_handle()
        self.err = self.dll.WFS_GetMlaData(
            self.handle,
            idx,
            self.info.mla_name,
            ctypes.byref(self.info.cam_pitch_um),
            ctypes.byref(self.info.lenslet_pitch_um),
            ctypes.byref(self.info.center_spot_offset_x),
            ctypes.byref(self.info.center_spot_offset_y),
            ctypes.byref(self.info.lenslet_f_um),
            ctypes.byref(self.info.grd_corr_0),
            ctypes.byref(self.info.grd_corr_45),
        )

    def setPupil(self, centroid_x, centroid_y, diameter_x, diameter_y):
        """Set pupil position and size"""
        self.info.centroid_x = ctypes.c_double(centroid_x)
        self.info.centroid_y = ctypes.c_double(centroid_y)
        self.info.diameter_x = ctypes.c_double(diameter_x)
        self.info.diameter_y = ctypes.c_double(diameter_y)
        err = self.dll.WFS_SetPupil(
            self.handle,
            self.info.centroid_x,
            self.info.centroid_y,
            self.info.diameter_x,
            self.info.diameter_y,
        )
        self.handleError(err)

    def getPupil(self):
        """Get actual pupil position and size"""
        err = self.dll.WFS_GetPupil(
            self.handle,
            ctypes.byref(self.info.centroid_x),
            ctypes.byref(self.info.centroid_y),
            ctypes.byref(self.info.diameter_x),
            ctypes.byref(self.info.diameter_y),
        )
        self.handleError(err)

    def setReferencePupils(self):
        """Sets reference plane to internal reference and then sets pupils

        Uses values stored in self.info dataclass"""
        # set WFS internal reference plane
        LOG.info("Set WFS to internal reference plane.")
        err = self.dll.WFS_SetReferencePlane(
            self.handle, self.dll.defines["WFS_REF_INTERNAL"],
        )
        self.handleError(err)

        # define pupil
        LOG.info("Define pupil to defaults:")
        LOG.info("Centroid_x = %6.3f", self.info.centroid_x.value)
        LOG.info("Centroid_y = %6.3f", self.info.centroid_y.value)
        LOG.info("Diameter_x = %6.3f", self.info.diameter_x.value)
        LOG.info("Diameter_y = %6.3f", self.info.diameter_y.value)

        # Do pupil set
        self.setPupil(
            self.info.centroid_x.value,
            self.info.centroid_y.value,
            self.info.diameter_x.value,
            self.info.diameter_y.value)

    def takeSpotfieldImageAuto(self):
        """Take a spotfield image using autoexposure. WFS20 has static master gain of 1.

        This function tries to find optimal exposure and gain settings and then it receives a spotfield image from the WFS camera into a driver buffer. The reference to this buffer is provided by function GetSpotfieldImage() and an image copy is returned by function GetSpotfieldImageCopy().
        The exposure and gain settings used for this image are returned.
        In case of still unsuited image exposure the function sets the appropriate status bits. Use function GetStatus() to check the reason.
        Bit         Name             Meaning if bit is set
        0x00000002  WFS_STATBIT_PTH  Power Too High (cam saturated)
        0x00000004  WFS_STATBIT_PTL  Power Too Low (low cam digits)
        0x00000008  WFS_STATBIT_HAL  High Ambient Light
        You may repeate calling the function until these status bits are cleared.
        When the trigger capability is activated by function SetTriggerMode() this function will wait for a trigger event for a short period of time (WFS_TIMEOUT_CAPTURE_TRIGGER = 0.1 sec.) prior to start exposure and will return with error WFS_ERROR_AWAITING_TRIGGER if no trigger event occured.
        You need to repeate calling this function until this error and status bit WFS_STATBIT_ATR disappear.
        Note: This function is not available in Highspeed Mode!
        """
        err = self.dll.WFS_TakeSpotfieldImageAutoExpos(
            self.handle,
            ctypes.byref(self.img.expos_act),
            ctypes.byref(self.img.master_gain_act),
        )
        self.handleError(err)
        LOG.info(
            "Took a spotfield image with %d exposure, %d gain",
            self.img.expos_act.value,
            self.img.master_gain_act.value,
        )

    def takeSpotfieldImage(self):
        """Take a spotfield image using static exposure. WFS20 has static master gain of 1.

        This function receives a spotfield image from the WFS camera into a driver buffer. The reference to this buffer is provided by function GetSpotfieldImage() and an image copy is returned by function GetSpotfieldImageCopy().
        In case of unsuited image exposure the function sets the appropriate status bits. Use function GetStatus() to check the reason.
        Bit         Name             Meaning if bit is set
        0x00000002  WFS_STATBIT_PTH  Power Too High (cam saturated)
        0x00000004  WFS_STATBIT_PTL  Power Too Low (low cam digits)
        0x00000008  WFS_STATBIT_HAL  High Ambient Light
        You need to set optimized exposure and gain settings by functions SetExposureTime() and SetMasterGain() and repeate calling the function until these status bits are cleared.
        Alternatively, you may use function GetImageAutoExpos().
        When the trigger capability is activated by function SetTriggerMode() this function will wait for a trigger event for a short period of time (WFS_TIMEOUT_CAPTURE_TRIGGER = 0.1 sec.) prior to start exposure and will return with error WFS_ERROR_AWAITING_TRIGGER if no trigger event occured.
        You need to repeate calling this function until this error and status bit WFS_STATBIT_ATR disappear.
        """
        err = self.dll.WFS_TakeSpotfieldImage(
            self.handle,
        )
        self.handleError(err)

    def setExposureGain(self, exposureTime=1.0, gain=1):
        """Set the exposure and gain for the instrument. WFS20 has static master gain of 1.

        Args:
            exposureTime (float, optional): exposure time in ms. Defaults to 1.0.
            gain (int, optional): In WFS20, master gain is fixed at 1. Defaults to 1.
        """
        exposureTimeActual = ctypes.c_double()
        err = self.dll.WFS_SetExposureTime(
            self.handle,
            exposureTime,
            ctypes.byref(exposureTimeActual)
        )
        self.handleError(err)
        return exposureTimeActual.value

    def getSpotfieldImage(self):
        """Get spotfield image from driver

        This function returns the reference to a spotfield image taken by functions TakeSpotfieldImage() or TakeSpotfieldImageAutoExpos().
        It returns also the image size.
        Note: This function is not available in Highspeed Mode!
        """
        err = self.dll.WFS_GetSpotfieldImage(
            self.handle,
            ctypes.byref(self.img.ImageBufferRef),
            ctypes.byref(self.img.rows),
            ctypes.byref(self.img.cols),
        )
        self.handleError(err)

    def calcBeamCentroidDia(self):
        """Get beam centroid and diameter as calculated by the driver

        This function calculates and returns the beam centroid and diameter data based on the intensity distribution of the WFS camera image in mm.
        Note:
        The beam centroid is highly sensitive to an increased black level of the camera image. For good accuracy it is recommended to set it as low as needed using function SetBlackLevelOffset.
        The beam diameter is calculated by the second moment formula.
        The initial beam is split into many spots by the lenslets which reduces accuracy also.
        This function is not available in Highspeed Mode!
        """
        # Calculate beam centroid diameter
        err = self.dll.WFS_CalcBeamCentroidDia(
            self.handle,
            ctypes.byref(self.info.centroid_x),
            ctypes.byref(self.info.centroid_y),
            ctypes.byref(self.info.diameter_x),
            ctypes.byref(self.info.diameter_y),
        )
        self.handleError(err, "calcBeamInformation")

    def calcBeamInformation(self):
        """Get a variety of beam information as calculated by the driver"""
        if self.hs_mode == True:
            LOG.debug("Function unavailable in highspeed mode")
            return

        # Calculate spot centroids
        err = self.dll.WFS_CalcSpotsCentrDiaIntens(
            self.handle,
            True,  # use dynamic noise cut features
            False,  # don't calculate spot diameters
        )
        self.handleError(err)

        self.calcBeamCentroidDia()

        self.getSpotDeviations()

        LOG.info("%s %s %s %s", self.info.centroid_x, self.info.centroid_y, self.info.diameter_x, self.info.diameter_y)

        # Driver-base calculations
        # CalcWavefront();
        # CalcZernikes();

    def calcSpotToReferenceDeviations(self, cancelWavefrontTilt=False):
        """Calculate spot to reference deviations

        This function calculates reference positions and deviations for all spots depending on the setting ref_idx(internal/user) set by function SetWavefrontReference.
        When option CancelWavefrontTilt is enabled the mean deviation in X and Y direction, which is measured within the pupil, is subtracted from the deviation data arrays.
        Reference positions can be retrieved using function GetSpotReferencePositions and calculated deviations by function GetSpotDeviations.
        """
        # Calculate beam centroid diameter
        err = self.dll.WFS_CalcSpotToReferenceDeviations(
            self.handle,
            cancelWavefrontTilt,
        )
        self.handleError(err, "spotToReference")

    def getSpotDeviations(self, cancelWavefrontTilt=False):
        """Calculate spot to reference deviations

        This function returns two two-dimensional arrays containing the actual X and Y spot deviations between centroid and reference spot positions in pixels calculated by function CalcSpotToReferenceDeviations.
        """
        self.calcSpotToReferenceDeviations()

        # Calculate beam centroid diameter
        err = self.dll.WFS_GetSpotDeviations(
            self.handle,
            self.img.arrayDeviationsX.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
            self.img.arrayDeviationsY.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
        )
        self.handleError(err, "getSpotDeviations")

    def displaySpotDeviations(self):
        """Display array deviations"""
        LOG.info("arrayDeviationsX: ", self.img.arrayDeviationsX)
        LOG.info("arrayDeviationsY: ", self.img.arrayDeviationsY)

    def getSpotIntensities(self):
        """Gets spot intensities from driver

        This function returns a two-dimensional array containing the spot intensities in arbitrary unit calculated by function WFS_CalcSpotsCentrDiaIntens.
        Note: Function WFS_CalcSpotsCentrDiaIntens is required to run successfully before calculated data can be retrieved.
        """
        # FIXME fix this hack to make sense in the interface above
        # I think it is also not correct. The function is a bit weird when
        # it comes to the documentation
        LOG.debug("%s %s %s %s", self.info.centroid_x, self.info.centroid_y, self.info.diameter_x, self.info.diameter_y)
        err = self.dll.WFS_GetSpotIntensities(self.handle, self.img.intensities.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),)
        self.handleError(err)

    def displaySpotIntensities(self):
        """Display plot of spot intensities

        Raises:
            NotImplementedError: Unimplemented
        """
        raise NotImplementedError()

    def buildSpotfieldImageArray(self):
        """Build received spotfield image array from received pointer in driver

        After the first time calling self.getSpotfieldImage, a pointer to the
        image buffer in the driver is available. This function MUST be called
        to create the actual spotfield image array in the data class the first
        time after taking a spotfield image or after changing the image resolution"""
        LOG.info("Spotfield image is %d rows by %d cols", self.img.rows.value, self.img.cols.value)
        self.img.SpotfieldImage = np.ctypeslib.as_array(self.img.ImageBufferRef, shape=(self.img.rows.value, self.img.cols.value))
        LOG.info("image: %s", self.img.SpotfieldImage)

    def getLine(self, lineIdx=0):
        """This function returns two linear arrays containing the minimum and maximum intensities within the image columns, respectively.

        Note: This function is not available in Highspeed Mode!"""
        err = self.dll.WFS_GetLine(
            self.handle,
            lineIdx,
            ctypes.byref(self.img.line.ctypes()),
        )
        self.handleError(err)

    def getLineView(self):
        """This function returns two linear arrays containing the minimum and maximum intensities within the image columns, respectively.

        Note: This function is not available in Highspeed Mode!"""
        err = self.dll.WFS_GetLineView(
            self.handle,
            self.img.lineMin.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
            self.img.lineMax.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
        )
        self.handleError(err)

    def setHighSpeedMode(self, hs_on=True, numCutDigits=30, adaptCentroids=True, allowAutoExposure=True):
        """Enable or disable high-speed mode and set mode parameters

        Enablign auto-exposure significantly slows down the framerate

        This function activates/deactivates the camera's Highspeed Mode for WFS10/WFS20 instruments.
        When activated, the camera calculates the spot centroid positions internally and sends the result to the WFS driver instead of sending raw spotfield images.
        Note:
        There is no camera image available when Highspeed Mode is activated!
        Highspeed Mode is not available for WFS150/WFS300/WFS30/WFS40 instruments!

        Args:
            hs_on (bool, optional): Enable or disable high-speed mode. Defaults to True.
            numCutDigits (int, optional): Number of values to treat as zero noise. Defaults to 30.
            adaptCentroids (bool, optional): Adapt centroids from previous runs. Defaults to True.
            allowAutoExposure (bool, optional): Allow autoexposure. Defaults to True.
        """
        err = self.dll.WFS_SetHighspeedMode(
            self.handle,
            hs_on,  # use highspeed mode (only for WFS10 and WFS20 instruments)
            adaptCentroids,  # adapt centroids in highspeed mode to previously measured centroids
            numCutDigits,  # cut lower nn digits in highspeed mode
            allowAutoExposure,  # allow autoexposure in highspeed mode (runs somewhat slower)
        )
        self.handleError(err)
        self.hs_mode = hs_on

    def getHighSpeedWindows(self):
        """Get number of windows and size of windows used for high-speed mode calculations

        This function returns data of the spot detection windows valid in Highspeed Mode. Window size and positions depend on options passed to function WFS_SetHighspeedMode().
        Note: This function is only available when Highspeed Mode is activated!
        """
        err = self.dll.WFS_GetHighspeedWindows(
            self.handle,
            ctypes.byref(self.info.hs_win_count_x),
            ctypes.byref(self.info.hs_win_count_y),
            ctypes.byref(self.info.hs_win_size_x),
            ctypes.byref(self.info.hs_win_size_y),
            self.info.hs_win_start_x.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)),
            self.info.hs_win_start_y.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)),
        )
        self.handleError(err)
        LOG.info(
            "Centroid detection windows are defined as follows:"
        )  # refer to WFS_GetHighspeedWindows function help
        LOG.info(
            "Count_x = %3d, Count_y = %3d",
            self.info.hs_win_count_x.value,
            self.info.hs_win_count_y.value,
        )
        LOG.info(
            "Size_x  = %3d, Size_y  = %3d",
            self.info.hs_win_size_x.value,
            self.info.hs_win_size_y.value,
        )

        LOG.info("Window coordinates x: ")
        LOG.info("".join(["%3d " % self.info.hs_win_start_x[i] for i in range(self.info.hs_win_count_x.value)]))
        LOG.info("Window coordinates y: ")
        LOG.info("".join(["%3d " % self.info.hs_win_start_y[i] for i in range(self.info.hs_win_count_y.value)]))

    def getSpotCentroids(self):
        """Get cetnroid positions as calculated by driver

        This function returns two two-dimensional arrays containing the centroid X and Y positions in pixels calculated by function WFS_CalcSpotsCentrDiaIntens.
        Note: Function WFS_CalcSpotsCentrDiaIntens is required to run successfully before calculated data can be retrieved.
        """
        err = self.dll.WFS_GetSpotCentroids(
            self.handle,
            self.img.arrayCentroidsX.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
            self.img.arrayCentroidsY.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
        )
        self.handleError(err)

    def calcZernikeLSF(self, order=4):
        """Calculate Zernike LSF based received data

        self.calcSpotToReferenceDeviations MUST be called after taking each image
        for this method to produce valid data

        Args:
            order (int, optional): Order of calculation, maximum 10. Defaults to 4.
        """
        self.img.zernikeOrders = ctypes.c_int(order)
        #data = ctypes.c_float()
        self.dll.WFS_ZernikeLsf.argtypes[1] = ctypes.POINTER(ctypes.c_int)
        err = self.dll.WFS_ZernikeLsf(
            self.handle,
            ctypes.byref(self.img.zernikeOrders),
            self.img.arrayZernikeUm.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
            self.img.arrayZernikeOrdersUm.ctypes.data_as(ctypes.POINTER(ctypes.c_float)),
            ctypes.byref(self.img.roCMm),
        )
        self.handleError(err)
